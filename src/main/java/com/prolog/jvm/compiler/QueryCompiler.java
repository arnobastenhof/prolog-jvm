package com.prolog.jvm.compiler;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.IOException;
import java.io.Reader;
import java.util.Map;

import com.prolog.jvm.compiler.ast.Ast;
import com.prolog.jvm.compiler.ast.AstWalker;
import com.prolog.jvm.compiler.parser.PrologParser;
import com.prolog.jvm.compiler.parser.Tokens;
import com.prolog.jvm.compiler.visitor.PrologVisitor;
import com.prolog.jvm.compiler.visitor.QueryVariableTracker;
import com.prolog.jvm.compiler.visitor.SourcePass;
import com.prolog.jvm.exceptions.RecognitionException;
import com.prolog.jvm.symbol.Scope;
import com.prolog.jvm.zip.api.PrologBytecode;

/**
 * A compiler for Prolog queries.
 *
 * @author Arno Bastenhof
 *
 */
public final class QueryCompiler extends AbstractCompiler {

	private final Map<Integer,String> queryVars;

	/**
	 *
	 * @param code the target for writing the generated bytecode to; not
	 * allowed to be null
	 * @param scope the ground scope to use when resolving symbols; not allowed
	 * to be null
	 * @param queryVars a mapping of local stack addresses to the names of the
	 * query variables allocated thereat; not allowed to be null
	 * @throws NullPointerException if {@code code == null || scope == null ||
	 * queryVars == null}
	 */
	public QueryCompiler(final PrologBytecode<?> code, final Scope scope,
			final Map<Integer,String> queryVars) {
		super(code, scope);
		this.queryVars = checkNotNull(queryVars);
	}

	/**
	 * Compiles the specified {@code source} by building an {@link Ast},
	 * resolving {@link Symbol}s and generating bytecode. In addition, to aid
	 * the computation of answers, a reference is kept for each query variable
	 * indicating the local stack address at which it is to be allocated.
	 */
	@Override
	public void compile(final Reader source)
			throws IOException, RecognitionException {
		super.compile(source);
		walkAst(this.root,
				new QueryVariableTracker(this.symbols, this.queryVars));
	}

	@Override
	protected SourcePass createSourcePassVisitor() {
		return new SourcePass(Tokens.IMPLIES);
	}

	@Override
	protected void parseSource(PrologParser parser)
			throws IOException, RecognitionException {
		parser.parseQuery();
	}

	@Override
	protected void walkAst(Ast root, PrologVisitor<Ast> visitor) {
		AstWalker.INSTANCE.walkQuery(root, visitor);
	}
}
